/////////////////////////////////////////////////////
//// CS 8803/4803 CGAI: Computer Graphics in AI Era
//// Assignment 1B: Neural SDF
/////////////////////////////////////////////////////

precision highp float;              //// set default precision of float variables to high precision

varying vec2 vUv;                   //// screen uv coordinates (varying, from vertex shader)
uniform vec2 iResolution;           //// screen resolution (uniform, from CPU)
uniform float iTime;                //// time elapsed (uniform, from CPU)

#define PI 3.1415925359

const vec3 CAM_POS = vec3(0, 1, 0);

vec3 rotate(vec3 p, vec3 ax, float ro)
{
    return mix(dot(p, ax) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);
}

/////////////////////////////////////////////////////
//// sdf functions
/////////////////////////////////////////////////////

float sdfPlane(vec3 p, float h)
{
    return p.y - h;
}

float sdfBunny(vec3 p)
{
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.0)
    {
        return length(p) - 0.9;
    }

    //// neural network weights for the bunny 

    vec4 f0_0=sin(p.y*vec4(1.74,-2.67,1.91,-1.93)+p.z*vec4(2.15,-3.05,.50,-1.32)+p.x*vec4(2.47,.30,-2.00,-2.75)+vec4(1.31,6.89,-8.25,.15));
    vec4 f0_1=sin(p.y*vec4(-.72,-3.13,4.36,-3.50)+p.z*vec4(3.39,3.58,-4.52,-1.10)+p.x*vec4(-1.02,-2.90,2.23,-.62)+vec4(1.61,-.84,-2.00,-.47));
    vec4 f0_2=sin(p.y*vec4(-1.47,.32,-.70,-1.51)+p.z*vec4(.17,.75,3.59,4.05)+p.x*vec4(-3.10,1.40,4.72,2.90)+vec4(-6.76,-6.43,2.41,-.66));
    vec4 f0_3=sin(p.y*vec4(-2.75,1.59,3.43,-3.39)+p.z*vec4(4.09,4.09,-2.34,1.23)+p.x*vec4(1.07,.65,-.18,-3.46)+vec4(-5.09,.73,3.06,3.35));
    vec4 f1_0=sin(mat4(.47,.12,-.23,-.04,.48,.06,-.24,.19,.12,.72,-.08,.39,.37,-.14,-.01,.06)*f0_0+
        mat4(-.62,-.40,-.81,-.30,-.34,.08,.26,.37,-.16,.38,-.09,.36,.02,-.50,.34,-.38)*f0_1+
        mat4(-.26,-.51,-.32,.32,-.67,.35,-.43,.93,.12,.34,.07,-.01,.67,.27,.43,-.02)*f0_2+
        mat4(.02,-.18,-.15,-.10,.47,-.07,.82,-.46,.18,.44,.39,-.94,-.20,-.28,-.20,.29)*f0_3+
        vec4(-.09,-3.49,2.17,-1.45))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.46,-.33,-.85,-.57,.41,.87,.25,.58,-.47,.16,-.14,-.06,-.70,-.82,-.20,.47)*f0_0+
        mat4(-.15,-.73,-.46,-.58,-.54,-.34,-.02,.12,.55,.32,.22,-.87,-.57,-.28,-.51,.10)*f0_1+
        mat4(.75,1.06,-.08,-.17,-.43,.69,1.07,.23,.46,-.02,.10,-.11,.21,-.70,-.08,-.48)*f0_2+
        mat4(.04,-.09,-.51,-.06,1.12,-.21,-.35,-.17,-.95,.49,.22,.99,.62,-.25,.06,-.20)*f0_3+
        vec4(-.61,2.91,-.17,.71))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.01,-.86,-.07,.46,.73,-.28,.83,.12,.16,.33,.28,-.55,-.21,-.02,.53,-.15)*f0_0+
        mat4(-.28,-.32,.19,-.28,.24,-.23,-.61,-.39,.26,.40,.18,.41,.21,.57,-.91,-.29)*f0_1+
        mat4(.23,-.40,-1.34,-.50,.08,-.04,-1.67,-.16,-.65,-.09,.38,-.22,-.14,-.34,.37,.05)*f0_2+
        mat4(-.47,-.23,-.57,-.05,.51,.04,.00,.27,.80,.29,-.09,-.53,-.20,-.41,-.64,-.12)*f0_3+
        vec4(1.08,4.00,-2.54,2.18))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.30,.38,.39,.53,.73,.73,-.06,.01,.54,-.07,-.19,.68,.59,.40,.04,.07)*f0_0+
        mat4(-.17,.44,-.61,.43,-.84,-.12,.65,-.50,.33,-.31,-.28,.13,.18,-.42,.14,.08)*f0_1+
        mat4(-.78,.06,-.18,.37,-.99,.49,.71,.15,.27,-.48,-.17,.25,.05,.10,-.40,-.21)*f0_2+
        mat4(-.17,-.27,.40,.18,-.24,.23,.03,-.83,-.30,-.38,.07,.21,-.45,-.24,.78,.50)*f0_3+
        vec4(2.14,-3.48,3.81,-1.43))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.83,.15,-.49,-.80,-.83,.16,1.24,.75,-.27,.18,-.13,1.05,.70,-.15,.30,.79)*f1_0+
        mat4(-.38,-.17,.34,.67,-.39,.09,.48,-.93,.19,.60,-.20,-.22,-.76,-.62,-.40,.01)*f1_1+
        mat4(.10,.22,.08,.13,-.42,-.11,.71,-.63,.02,.46,-.07,-.46,-.37,.07,.15,.14)*f1_2+
        mat4(.09,-.48,-.38,.40,-.57,-.88,-.14,-.25,.20,.95,.86,-1.08,.46,.04,.53,-.82)*f1_3+
        vec4(3.47,-3.66,3.06,.84))/1.4+f1_0;
    vec4 f2_1=sin(mat4(1.03,.03,-.76,-.03,.84,.66,-.49,.74,-.09,-.85,-.55,.17,.07,.85,-.55,-.20)*f1_0+
        mat4(-.55,1.13,.41,-.21,-.55,.19,.49,.67,.40,1.80,-.82,-.83,-1.02,.78,-.42,-.51)*f1_1+
        mat4(.77,-.88,.64,1.10,-.49,1.05,-.43,-.38,.66,-.63,.02,.11,-.24,-.23,.49,-.65)*f1_2+
        mat4(-.66,1.90,.02,-.48,.22,-.62,-.68,-.44,.52,-.57,.16,-.61,-.03,-.02,-.88,-.23)*f1_3+
        vec4(.58,-3.00,-2.53,.14))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-.44,-.06,.30,-.37,.27,-.23,-.56,.15,.03,-.14,-.08,.72,.76,-.58,.55,.29)*f1_0+
        mat4(.31,.23,.42,-.17,.37,-.05,.39,.46,-1.14,.32,.06,-.28,.28,-.21,-.58,.62)*f1_1+
        mat4(.92,-.16,.86,-.09,-.12,.33,-.49,-.24,.29,-.19,.95,-.40,-.87,.08,.08,-.71)*f1_2+
        mat4(-.45,.67,1.07,-.14,-.56,.06,-.81,-.15,-.57,-.24,-1.09,.69,-.44,-.32,-.00,-.07)*f1_3+
        vec4(-4.43,-1.86,-2.87,1.45))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.58,.25,.01,-.54,.34,.56,.61,-.79,-.01,.05,-.57,-1.31,.74,.78,-.10,-.11)*f1_0+
        mat4(-.03,-.48,-.24,.01,.10,.23,.22,-.05,.76,.29,-.37,.02,.54,-.07,.27,.38)*f1_1+
        mat4(.31,-1.03,.24,.95,.80,.29,.43,.61,-.04,-.22,-.06,-.52,-.46,.35,.07,-.07)*f1_2+
        mat4(.47,-.12,-.62,.06,.47,-.41,.53,-2.14,-.59,.16,.74,-.58,.32,.66,-.30,-.18)*f1_3+
        vec4(-2.86,-3.27,-.55,2.87))/1.4+f1_3;
    return dot(f2_0,vec4(-.08,.03,.07,-.03))+
        dot(f2_1,vec4(-.03,-.02,-.06,-.07))+
        dot(f2_2,vec4(.05,-.09,.03,.11))+
        dot(f2_3,vec4(.03,.06,-.06,-.03))+
        -0.014;
}

/////////////////////////////////////////////////////
//// Step 1: training a neural SDF model
//// You are asked to train your own neural SDF model on Colab. 
//// Your implementation should take place in neural_sdf.ipynb.
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 2: copy neural SDF weights to GLSL
//// In this step, you are asked to the network weights you have trained from the text file to the function sdfCow().
//// You should replace the default implementation (a sphere) with your own network weights. 
/////////////////////////////////////////////////////

float sdfCow(vec3 p)
{
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 3. + PI/3.0);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    vec4 f0_0=sin(p.y*vec4(1.06,-1.73,-.02,-3.08)+p.z*vec4(1.58,2.61,.17,-1.20)+p.x*vec4(-.87,3.30,-1.45,-4.04)+vec4(-5.02,4.63,1.74,.93));
    vec4 f0_1=sin(p.y*vec4(-.01,-2.49,-.41,-1.04)+p.z*vec4(1.95,.96,1.36,-.87)+p.x*vec4(2.38,-2.08,-2.24,2.82)+vec4(.11,4.63,3.68,-.19));
    vec4 f0_2=sin(p.y*vec4(.87,-1.49,3.29,-2.86)+p.z*vec4(1.93,-4.65,-2.68,2.22)+p.x*vec4(2.46,3.14,3.43,1.96)+vec4(-1.04,-6.52,-7.52,-3.35));
    vec4 f0_3=sin(p.y*vec4(2.66,1.76,-2.75,2.80)+p.z*vec4(2.27,4.85,-.52,2.29)+p.x*vec4(-1.13,-2.15,-.83,3.81)+vec4(1.81,-3.03,3.56,4.49));
    vec4 f1_0=sin(mat4(-.71,-.55,.89,-.46,-.69,.39,.46,.35,-.56,-.15,.51,.54,-.23,-.41,.10,-.53)*f0_0+
        mat4(.60,-.52,.33,-.07,.02,-.03,.96,.24,.03,-.02,-.72,.09,-.08,.57,-.09,.49)*f0_1+
        mat4(.60,-.42,.36,.61,-.09,-.07,-.36,-.56,.13,-.22,.07,-.48,-.40,-.07,-.49,-.21)*f0_2+
        mat4(-.26,.45,.21,.09,.16,-.04,.24,.60,.02,.11,.14,-.27,-.29,.28,.72,-.26)*f0_3+
        vec4(2.80,-1.95,-.53,-1.28))/1.0+f0_0;
    vec4 f1_1=sin(mat4(.58,.43,-.39,1.03,.08,-.40,.55,-.29,.88,-.06,.11,-.34,.43,.36,.56,-.79)*f0_0+
        mat4(-.55,.59,-.25,-.00,.30,-.33,.96,.72,-.38,-.26,-.59,1.53,-.31,.28,.05,.99)*f0_1+
        mat4(.53,-.06,-.09,.26,.25,.46,-.02,-.82,.18,.31,-.28,-.20,.11,-.63,.32,-.17)*f0_2+
        mat4(.31,.12,.08,-.52,-.23,-.42,-.10,.91,.10,-.28,-.18,-.54,.34,.31,.73,-.49)*f0_3+
        vec4(2.24,-1.09,3.97,.27))/1.0+f0_1;
    vec4 f1_2=sin(mat4(-.20,.27,.14,.05,-.49,-.20,-.26,.43,-.81,-.54,-.25,.05,.15,.04,-.76,.29)*f0_0+
        mat4(.15,.10,.34,.60,-.92,-.46,-.30,-.18,-.11,.45,.93,.40,.30,-.79,.28,-.16)*f0_1+
        mat4(.40,-.01,-.00,.68,.27,.35,.28,.03,.08,.92,-.42,.39,-.53,-.77,.54,.40)*f0_2+
        mat4(.22,-.13,-.46,-.23,.52,.04,.45,.34,-.43,.35,-.96,-.54,.08,-.39,-.78,-.11)*f0_3+
        vec4(-2.82,1.03,3.02,2.86))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.42,.45,.84,-.45,.11,-.55,-.60,.08,.29,.48,.38,.78,.11,.05,-.27,-.35)*f0_0+
        mat4(.10,-.37,-.62,1.25,-.48,-.14,-.50,.79,-.11,-.35,.67,.29,-.21,-.15,.13,-.15)*f0_1+
        mat4(-.39,.39,-.18,.39,-.08,.34,-.03,.70,.06,.35,.32,-.26,.05,-.75,.24,-.04)*f0_2+
        mat4(-1.01,-.35,.19,.19,.40,-.24,.11,-.50,.23,.72,.06,-.20,.19,.29,-.64,.18)*f0_3+
        vec4(3.29,-3.71,1.51,2.82))/1.0+f0_3;
    vec4 f2_0=sin(mat4(.67,-.18,.61,-.51,-.11,-.20,-.67,.44,.15,.49,.13,.54,-.50,-.53,.07,.02)*f1_0+
        mat4(.25,.39,.79,-.43,-.22,-.03,-.10,-.41,.06,.62,.21,.16,.12,-.30,.22,.24)*f1_1+
        mat4(-.22,-.50,-.48,.68,-.11,-.62,.27,.32,-.49,.71,.48,.90,-.19,.11,.48,.17)*f1_2+
        mat4(-.53,.60,.05,1.35,.34,.17,-.13,.30,-.75,.82,1.13,1.55,-.65,-1.09,-.51,-.34)*f1_3+
        vec4(.39,-2.16,-.03,-1.87))/1.4+f1_0;
    vec4 f2_1=sin(mat4(.07,-.39,1.24,.41,-.76,.25,.45,.02,-.19,-.36,.91,.00,.28,-.04,-.40,-1.02)*f1_0+
        mat4(.54,-1.22,-.59,.19,-.96,-.04,-.91,.40,-.43,-.19,.51,-.33,.21,.32,.50,.33)*f1_1+
        mat4(-.59,-.23,-.09,.11,.68,.16,-.24,-.12,-.75,.18,-.26,-.03,-.61,.34,-.25,-1.00)*f1_2+
        mat4(-.13,-.31,-.01,-.38,.14,.24,-.24,.35,.49,-1.23,-.89,-.32,.44,.21,-.16,.31)*f1_3+
        vec4(.15,-.65,2.94,1.03))/1.4+f1_1;
    vec4 f2_2=sin(mat4(-1.24,-.36,-.27,-.00,.65,-.11,-.41,-.29,.15,.42,.17,.87,-.33,.18,-.32,.53)*f1_0+
        mat4(-.29,-.25,-.90,.12,.08,-.62,.90,-.22,.11,-.46,.36,-.61,.18,.33,-.36,.55)*f1_1+
        mat4(-.27,.51,.48,-.15,-.44,.31,-.64,-.46,-.26,-.39,-.82,-.05,-1.07,.78,-.03,-.23)*f1_2+
        mat4(-.47,.00,-.69,.60,-.49,-.51,.00,-1.15,-.26,-.40,-.71,-.52,.19,.33,-.21,-.37)*f1_3+
        vec4(3.03,-1.97,2.13,.40))/1.4+f1_2;
    vec4 f2_3=sin(mat4(-.64,.45,-.16,-.42,-1.03,-.94,-.27,.05,.17,1.07,-.11,-.40,.72,-.44,.84,.63)*f1_0+
        mat4(-.01,-.01,-.82,.77,-.42,-.76,.42,-.25,.57,.88,.66,-.65,-.49,-.24,-.42,.05)*f1_1+
        mat4(.41,-.49,-.36,-.91,.17,-.05,.38,.68,.86,.30,-.01,.76,.05,-.08,.38,-.12)*f1_2+
        mat4(-.61,-.19,-.33,.69,.06,.40,-.01,-.14,-.57,.28,-.68,-.58,.07,-.64,-.01,.16)*f1_3+
        vec4(1.89,-.35,-2.51,3.80))/1.4+f1_3;
    return dot(f2_0,vec4(.05,-.04,.09,-.02))+
        dot(f2_1,vec4(-.03,-.10,-.05,.08))+
        dot(f2_2,vec4(.04,-.06,.05,-.04))+
        dot(f2_3,vec4(-.05,.07,.12,-.04))+
        -0.145;
    //// your implementation ends
}

float sdfTeddy(vec3 p) {
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.);

    // sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.)
    {
        return length(p) - 0.9;
    }

    vec4 f0_0=sin(p.y*vec4(-4.67,.95,2.87,.27)+p.z*vec4(1.24,-.34,-4.28,2.29)+p.x*vec4(-.87,2.23,-1.63,-3.31)+vec4(1.16,2.99,-4.89,-5.51));
    vec4 f0_1=sin(p.y*vec4(-3.30,3.95,3.75,-.33)+p.z*vec4(2.57,2.33,1.91,3.50)+p.x*vec4(-.71,.88,1.47,-.16)+vec4(6.76,4.63,5.86,5.50));
    vec4 f0_2=sin(p.y*vec4(3.94,3.51,.11,-.42)+p.z*vec4(-3.17,1.12,2.10,.14)+p.x*vec4(1.00,1.75,-3.67,-3.49)+vec4(-2.66,7.70,4.83,4.75));
    vec4 f0_3=sin(p.y*vec4(-.04,2.75,-1.36,-1.82)+p.z*vec4(-2.06,1.15,-2.29,4.01)+p.x*vec4(1.90,-2.76,4.12,1.09)+vec4(8.84,8.09,1.45,-2.69));
    vec4 f1_0=sin(mat4(-.28,.69,-.09,.11,-.63,-.57,-.48,.49,-.26,-.31,-.17,-.82,.29,.74,-.70,.29)*f0_0+
        mat4(.12,-.09,-.06,-.12,.03,1.09,-.14,-.55,.29,-.82,.31,.98,.62,-.47,.28,-.91)*f0_1+
        mat4(.22,.14,.45,-.04,-.34,-.38,-.56,.57,.15,.09,-.72,-.55,-.48,-.88,.19,-.38)*f0_2+
        mat4(-.52,.28,.72,.14,.24,-.06,-.29,-.58,.16,.07,-.10,.32,.70,-.15,-.68,-.60)*f0_3+
        vec4(2.10,3.51,4.01,.95))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.41,-.49,-.23,-.30,.59,-.76,-.47,.35,-.39,.54,-.13,.45,-.41,-.31,-.01,-.17)*f0_0+
        mat4(-.19,-.04,-.52,-.08,.37,-.37,.00,.31,-.61,.47,-.46,-.37,.41,-.61,-.25,-.21)*f0_1+
        mat4(-.25,-.01,-.31,.55,.36,.30,.41,-.66,-.93,.06,-.62,.51,.27,-.94,.53,-.04)*f0_2+
        mat4(.91,.68,-.92,-.10,.52,.20,.33,-.38,.15,.32,-.54,.20,.49,-.46,.28,.07)*f0_3+
        vec4(-.41,3.95,1.39,3.61))/1.0+f0_1;
    vec4 f1_2=sin(mat4(-.06,.02,.14,.30,-.45,-.40,.57,.63,-.40,.80,1.00,-.16,.61,-.25,-.91,-.12)*f0_0+
        mat4(-.37,.57,-.26,.47,.42,.07,-.45,.22,.06,-.95,.14,-.02,-.63,.11,.22,-.73)*f0_1+
        mat4(.66,-.17,.04,-.45,-.14,.14,-1.25,.73,-.52,-.31,.08,-.09,.52,-.41,.08,.12)*f0_2+
        mat4(-.75,-.32,1.19,-.57,.13,.47,-.08,-.37,.51,-.29,-.24,.16,-.67,.08,.04,-.43)*f0_3+
        vec4(-1.41,1.77,-.07,-2.52))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.66,-.08,.17,.14,.14,.30,.31,.08,.05,.17,-.26,-.03,-.45,-.30,-.70,.25)*f0_0+
        mat4(-.65,.07,.07,.63,-.50,.83,.16,.12,.32,-.21,.05,.02,.48,-.79,-.61,.47)*f0_1+
        mat4(.50,-.36,-.64,-.34,.15,-.50,.48,.40,-.15,-.19,-.62,.59,.03,-.15,-.08,-.44)*f0_2+
        mat4(-.15,-.05,.40,.11,.10,-.66,-.19,-.15,-.04,.79,.22,-.44,.30,.08,-.62,-.12)*f0_3+
        vec4(-1.39,-1.63,2.17,-1.16))/1.0+f0_3;
    vec4 f2_0=sin(mat4(-.63,-.32,.13,-.26,.02,-.21,-.02,.41,.76,.02,-.50,-.73,.41,.06,.23,.17)*f1_0+
        mat4(.26,.16,-1.27,-.40,.17,.48,-1.04,.66,-.78,.08,.86,-.50,.34,1.45,-.10,.03)*f1_1+
        mat4(-.35,.45,-.41,.41,-.21,-.01,.02,.37,.28,1.35,.02,.22,-.26,-.75,-.01,.38)*f1_2+
        mat4(-.32,-.00,-.40,.41,-.24,-.45,-.02,-.84,-.34,.17,-.02,-1.18,.94,-1.28,.45,-.68)*f1_3+
        vec4(-3.86,.11,-2.77,1.83))/1.4+f1_0;
    vec4 f2_1=sin(mat4(.72,-1.58,-.97,-.97,-.20,-.03,.22,-.55,-.77,-.62,.13,.93,-.98,-.02,-.16,-.02)*f1_0+
        mat4(-1.98,-.26,.91,-.38,-.52,-.36,.71,.59,.24,-.24,-1.54,.66,.72,.35,.52,.19)*f1_1+
        mat4(.15,-.08,.15,-.14,-1.11,.02,-.03,-.24,-1.11,1.31,-.72,-.59,1.02,.03,-.23,-.01)*f1_2+
        mat4(.42,-.39,-.25,.28,.46,.11,-.45,.99,-.34,.04,-1.37,.53,.26,-1.06,.26,.54)*f1_3+
        vec4(-.73,2.48,-2.32,-3.46))/1.4+f1_1;
    vec4 f2_2=sin(mat4(1.03,.55,-.43,-.11,.45,-.27,-.14,.24,.07,-.26,1.11,.11,.04,-.94,.40,-.18)*f1_0+
        mat4(-.13,-.75,.38,-.23,.16,-.07,.96,.06,-.04,-.25,-.06,.43,.48,-.49,-.56,.05)*f1_1+
        mat4(.20,-.53,-.06,-.21,.16,.47,.16,-.20,-.19,-1.04,-.86,-.01,.38,-.16,.75,.23)*f1_2+
        mat4(.45,.88,.02,-.86,-1.60,.20,-.07,-.36,-.01,.31,.72,.50,.41,1.44,.41,.69)*f1_3+
        vec4(.12,-1.95,-1.99,.82))/1.4+f1_2;
    vec4 f2_3=sin(mat4(-.20,.25,-.95,-.71,.53,.33,.51,-.19,.96,-1.15,-.05,.72,.95,-.32,.35,-.59)*f1_0+
        mat4(.26,-.26,-.61,.07,.68,.41,.10,-.67,.07,-.59,-.32,1.07,-.11,.08,.48,-.09)*f1_1+
        mat4(-.39,-.25,.51,-.76,-.32,.84,-.53,.34,-.47,.58,-.20,.57,.11,-.72,.28,-.97)*f1_2+
        mat4(-.07,1.11,.08,-.62,-.38,-.48,-.16,.14,.58,.66,-.45,.81,-.53,-.55,.40,.26)*f1_3+
        vec4(2.39,3.41,-3.03,3.72))/1.4+f1_3;
    return dot(f2_0,vec4(.05,.04,-.04,-.03))+
        dot(f2_1,vec4(.02,-.03,.03,-.04))+
        dot(f2_2,vec4(.04,-.03,.04,.10))+
        dot(f2_3,vec4(-.03,-.08,.06,-.04))+
        0.068;
}

float sdfUnion(float d1, float d2)
{
    return min(d1, d2);
}

/////////////////////////////////////////////////////
//// Step 3: scene sdf
//// You are asked to use the sdf boolean operations to draw the bunny and the cow in the scene.
//// The bunny is located in the center of vec3(-1.0, 1., 4.), and the cow is located in the center of vec3(1.0, 1., 4.).
/////////////////////////////////////////////////////

//// sdf: p - query point
float sdf(vec3 p)
{
    float s = 0.;

    float plane_h = -0.1;

    //// calculate the sdf based on all objects in the scene

    //// your implementation starts
    float dPlane = sdfPlane(p, plane_h);
    float dBunny = sdfBunny(p - vec3(-1.0, 1.0, 4.0));
    float dTeddy = sdfTeddy(p - vec3(1.0, 1.0, 4.0));

    s = sdfUnion(dPlane, sdfUnion(dBunny, dTeddy));
    //// your implementation ends

    return s;
}

/////////////////////////////////////////////////////
//// ray marching
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 4: ray marching
//// You are asked to implement the ray marching algorithm within the following for-loop.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// ray marching: origin - ray origin; dir - ray direction 
float rayMarching(vec3 origin, vec3 dir)
{
    float s = 0.0;
    float t = 0.0;
    for(int i = 0; i < 100; i++)
    {
        //// your implementation starts
        vec3 p = origin + dir * t;
        s = sdf(p);
        if (s < 0.01) break;
        t += s;
        if (t > 100.0) return 100.0; // No intersection found within the maximum distance
        //// your implementation ends
    }
    
    return t;
}
/////////////////////////////////////////////////////
//// normal calculation
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 5: normal calculation
//// You are asked to calculate the sdf normal based on finite difference.
//// You are allowed to reuse your previous implementation in A1a for this function.
/////////////////////////////////////////////////////

//// normal: p - query point
vec3 normal(vec3 p)
{
    float s = sdf(p);          //// sdf value in p
    float dx = 0.01;           //// step size for finite difference

    //// your implementation starts
    
    vec3 n = normalize(vec3(
        sdf(p + vec3(dx, 0.0, 0.0)) - s,
        sdf(p + vec3(0.0, dx, 0.0)) - s,
        sdf(p + vec3(0.0, 0.0, dx)) - s
    ));

    return n;
}

/////////////////////////////////////////////////////
//// Phong shading
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 6: lighting and coloring
//// You are asked to specify the color for the two neural SDF objects in the scene.
//// Each object must have a separate color without mixing.
//// Notice that we have implemented the default Phong shading model for you.
/////////////////////////////////////////////////////

vec3 phong_shading(vec3 p, vec3 n)
{
    //// background
    if(p.z > 20.0)
    {
        vec3 color = vec3(0.04, 0.16, 0.33);
        return color;
    }

    //// phong shading
    vec3 lightPos = vec3(4. * sin(iTime), 4., 4. * cos(iTime));
    vec3 l = normalize(lightPos - p);
    float amb = 0.1;
    float dif = max(dot(n, l), 0.) * 0.7;
    vec3 eye = CAM_POS;
    float spec = pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.9;

    vec3 sunDir = normalize(vec3(0, 1, -1)); //// parallel light direction
    float sunDif = max(dot(n, sunDir), 0.) * 0.2;

    //// shadow
    float s = rayMarching(p + n * 0.02, l);
    if(s < length(lightPos - p))
        dif *= .2;

    vec3 color = vec3(1.0);

    //// your implementation starts
    if (p.y < 0.2) {
        color = vec3(0.19, 0.67, 0.31);
    } else if (p.x < 0.2) {
        color = vec3(0.73, 0.85, 0.91);
    } else {
        color = vec3(0.37, 0.25, 0.11);
    }
    
    //// your implementation ends

    return (amb + dif + spec + sunDif) * color;
}

/////////////////////////////////////////////////////
//// main function
/////////////////////////////////////////////////////

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;         //// screen uv
    vec3 origin = CAM_POS;                                                  //// camera position 
    vec3 dir = normalize(vec3(uv.x, uv.y, 1));                              //// camera direction
    float s = rayMarching(origin, dir);                                     //// ray marching
    vec3 p = origin + dir * s;                                              //// ray-sdf intersection
    vec3 n = normal(p);                                                     //// sdf normal
    vec3 color = phong_shading(p, n);                                       //// phong shading
    fragColor = vec4(color, 1.);                                            //// fragment color
}

void main()
{
    mainImage(gl_FragColor, gl_FragCoord.xy);
}